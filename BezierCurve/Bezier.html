<!DOCTYPE>
<html xml:lang>
<head>
  <title>Bezier</title>

  <style>
    #canvas{}
      body {
        display: flex;
        justify-content: center;
      }
  </style>

  <script type="text/javascript">

  var numControls = 4;
  var control = [[80,150], [20,450], [350,400], [450,60], [320,50], [200,80], [170,150], [210,220], [250,200],  [270,170]];
  var numPoints = 80;
  var algorithm = 0;
  var canvas;
  var context;
  var startX;
  var startY;
  var endX;
  var endY;
  var param_t = 0.3;

  function init(){
    canvas = document.getElementById('canvas');
    context = canvas.getContext('2d');
    context.imageSmoothingEnabled = true;
    context.fillStyle = "#ffffff";
    context.strokeStyle = "#000000";
    context.fillRect(0,0,1080,1080);
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('mousemove', onMouseMove);

    repaint();
  }

  var active = -1;
  function onMouseDown(evt)
  {
    var x = evt.pageX;
    var y = evt.pageY;
    x -=canvas.offsetLeft;
    y -=canvas.offsetTop;
    startX = x;
    startY = y;
    active = -1;
    for( i = 0; i < numControls; ++i )
    {
      if( Math.abs(startX - control[ i ][ 0 ]) < 10
      && Math.abs(startY - control[ i ][ 1 ]) < 10 )
      {
        active = i;
      }
    }
    repaint();
  }

  function onMouseMove(evt)
  {
    if( active == - 1)
      return;
    var x = evt.pageX;
    var y = evt.pageY;
    x -= canvas.offsetLeft;
    y -= canvas.offsetTop;
    let midX = x;
    let midY = y;
    control[active][0] = midX;
    control[active][1] = midY;
    repaint();
  }


  function onMouseUp(evt)
  {
    if(active != -1 )
    {
      var x = evt.pageX;
      var y = evt.pageY;

      x -= canvas.offsetLeft;
      y -= canvas.offsetTop;

      endX = x;
      endY = y;

      control[active][0]=endX;
      control[active][1]=endY;

      active = -1;

      repaint();
    }
  }

  function repaint()
  {
    context.clearRect(0,0,1920,1080);
    drawBezier();
    drawControls();
  }

  function drawLine( startX, startY, endX, endY, color = "#000000" )
  {
    context.strokeStyle = color;
    context.beginPath();
    context.moveTo(startX, startY);
    context.lineTo( endX, endY );
    context.stroke();
  }

  function drawControls()
  {
    for( i = 0; i < numControls - 1; ++i )
      drawLine(control[i][0], control[i][1], control[i+1][0], control[i+1][1], '#000000')

    for( i = 0; i < numControls; ++i )
    {
      context.strokeStyle = "#000000";
      context.beginPath();
      context.arc(control[i][0], control[i][1], 5, 0, 2*Math.PI);
      context.stroke();
      context.fillStyle = 'black';
      context.font = '20px Arial';
      context.strokeText( i, control[i][0]+10, control[i][1] );
    }

    if( active != -1 )
    {
      context.beginPath();
      context.arc( control[active][0],
        control[active][1],
        2, 0, 2.0 * Math.PI);
        context.stroke();
      }
    }

    var point;
    function drawBezier()
    {
      context.lineWidth = 2;
      var color;
      if (algorithm)
        color = '#4040e0';
      else
        color = '#49006A';
      var last = control[ 0 ];
      for( i = 1; i <= numPoints; ++i )
      {
        point = bezier( i / numPoints );
        drawLine(last[0], last[1], point[0], point[1], color);
        last = point;
      }
      point = bezier( param_t );
    }

    function bezier( t )
    {
      var pos;
      if( algorithm == 0 )
        pos = deCasteljau( t, 0, numControls - 1, numControls - 1 );
      else
        pos = deCasteljauIterativ( t );
      return pos;
    }

    function add( v1, v2 ) { return [ v1[ 0 ] + v2[ 0 ], v1[ 1 ] + v2[ 1 ] ]; }
    function mul( t, v ) { return [ v[ 0 ] * t, v[ 1 ] * t ]; }

    function deCasteljau( t, i, j, degree )
    {
      if (degree == 0)
        return add( mul((1.0 - t), control[i]), mul(t, control[j]));
      let p1 = deCasteljau(t,i,j-1,degree-1);
      let p2 = deCasteljau(t,i+1,j,degree-1);
      if(t == param_t)
        drawLine(p1[0], p1[1], p2[0], p2[1], colors[degree-1]);
      return add( mul((1.0 - t), p1), mul(t, p2) );
    }

    function deCasteljauIterativ( t )
    {
      let degree = numControls - 1;
      var p = control.slice();
	    do {
        var b = [];
		    for (var i = 0; i < degree; i++) {
		      var p1 = p[i];
		      var p2 = p[i+1];
		      b[i] = add( mul( (1-t), p1 ), mul( t, p2 ) );
          if(t == param_t)
            drawLine(p1[0], p1[1], p2[0], p2[1], colors[numControls-degree+12]);
		    }
		    degree--;
        p = b;
	    } while(degree+1 > 1)
	    return p[0];
    }

    var colors = [ "#FFF7F3", "#FDE0DD", "#FCC5C0", "#FA9FB5", "#F768A1", "#DD3497", "#AE017E", "#7A0177", "#49006A",
                   "#FF3333", "#FF6666", "#FF9999", "#FFCCCC", "#FFFFFF", "#CCCCFF", "#9999FF", "#6666FF", "#3333FF"];

    function param( t )
    {
      param_t = t/100.0;
      var display = document.getElementById( "param_t" );
      display.innerHTML = param_t.toFixed(2);
      repaint();
    }

    function setDegree( degree )
    {
      numControls = parseInt(degree) + 1;
      var display = document.getElementById( "degree" );
      display.innerHTML = degree;
      repaint();
    }

    function algoChange( algo )
    {
      if( algo == "Iterativ" )
        algorithm = 1;
      else
        algorithm = 0;
      repaint();
    }
    </script>
  </head>

  <body onload="init()">
    <div id="content">
      <p>
        t = <input type="range" id="param_slider" min="0" max="100" oninput="param(this.value)" onchange="param(this.value)"/>
        <span id="param_t"></span>
        Grad = <input type="range" id="degree_slider" min="1" max="9" oninput="setDegree(this.value)" onchange="setDegree(this.value)"/>
        <span id="degree"></span>
        <select name="Algorithmus" size="2" onchange="algoChange(this.value)">
          <option>Rekursiv</option>
          <option>Iterativ</option>
        </select>
      </p>
      <canvas id="canvas" width="1900" height="850"></canvas>
    </div>
  </body>
</html>
