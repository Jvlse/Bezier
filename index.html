<!DOCTYPE html>
<html xml:lang>
    <head>
        <title>Phong</title>
        <style>
            body {
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
            }
        </style>

        <script type="text/javascript" src="glmatrix-min.js"></script>

        <script id="shader-vs" type="shader/vertex">
        attribute vec3 aVertexPosition, aVertexColor;
        varying vec4 colorVector, specularityVector;
        uniform mat4 MVMatrix, PMatrix, NormalMatrix;
        vec3 LightDirection = vec3(0.5, 0.5, 1.0), ObjectColor = vec3(1.0, 0.1, 0.1), LightColor = vec3(1.0, 1.0, 1.0);

        void main(void) {
            vec3 normal = -normalize((NormalMatrix * vec4(aVertexColor, 0.0)).xyz);
            colorVector = vec4(LightColor * ObjectColor * max(0.0, dot(normalize(LightDirection), normal)), 1.0);
            specularityVector = vec4(vec3(0.6, 0.6, 0.6) * pow(max(0.0, dot(-reflect(LightDirection, normal), vec3(0.0, 0.0, 1.0))), 1.0), 1.0);
            gl_Position =  PMatrix * MVMatrix * (vec4(aVertexPosition, 1)) + vec4(0,1,0,0);
        }
        </script>

        <script id="shader-fs" type="shader/fragment">
        precision mediump float;
        varying vec4 colorVector, specularityVector;

        void main(void) {
            gl_FragColor = (1.0 * colorVector) + (1.0 * specularityVector);    
        }
        </script>

        <script type="text/javascript">

            var gl;
            function initGL(canvas) {
                gl = canvas.getContext("experimental-webgl");
                gl.viewportWidth = canvas.width;
                gl.viewportHeight = canvas.height;
                if (!gl) {
                    alert("WebGL not supported.");
                }
            }

            function getShader(gl, id) {
                var shaderScript = document.getElementById(id);

                var str = "";
                var k = shaderScript.firstChild;
                while (k) {
                    if (k.nodeType == 3)
                        str += k.textContent;
                    k = k.nextSibling;
                }

                var shader;
                if (shaderScript.type == "shader/fragment")
                    shader = gl.createShader(gl.FRAGMENT_SHADER);
                else if (shaderScript.type == "shader/vertex")
                    shader = gl.createShader(gl.VERTEX_SHADER);
                else
                    return null;

                gl.shaderSource(shader, str);
                gl.compileShader(shader);
                
                return shader;
            }

            var shaderProgram;
            function initShaders() {
                var fragmentShader = getShader(gl, "shader-fs"), vertexShader = getShader(gl, "shader-vs");

                shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);
                gl.useProgram(shaderProgram);

                gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexPosition"));

                shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
                gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexColor"));
            }

            var mvMatrix = glMatrix.mat4.create(), pMatrix = glMatrix.mat4.create();
            function setUniforms() {
                var normalMatrix = glMatrix.mat4.clone(mvMatrix);
                glMatrix.mat4.invert(normalMatrix, normalMatrix);
                glMatrix.mat4.transpose(normalMatrix, normalMatrix);
                
                gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "NormalMatrix"), false, normalMatrix);
                gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "PMatrix"), false, pMatrix);
                gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "MVMatrix"), false, mvMatrix);
            }

            var icosahedronVertexPositionBuffer, icosahedronColorBuffer, icosahedronCenterPosition = { x: 0, y: 0, z: 0 };
            function initBuffers() {
                icosahedronVertexPositionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, icosahedronVertexPositionBuffer);
                const X = 0.525731112119133606, Z = 0.850650808352039932;
                var vertices = [
                    -X, 0.0, Z,     0.0, Z, X,      X, 0.0, Z,
                    -X, 0.0, Z,     -Z, X, 0.0,     0.0, Z, X,
                    -Z, X, 0.0,     0.0, Z, -X,     0.0, Z, X,
                    0.0, Z, X,      0.0, Z, -X,     Z, X, 0.0,
                    0.0, Z, X,      Z, X, 0.0,      X, 0.0, Z,
                    Z, X, 0.0,      Z, -X, 0.0,     X, 0.0, Z,
                    Z, X, 0.0,      X, 0.0, -Z,     Z, -X, 0.0,
                    0.0, Z, -X,     X, 0.0, -Z,     Z, X, 0.0,
                    0.0, Z, -X,     -X, 0.0, -Z,    X, 0.0, -Z,
                    -X, 0.0, -Z,    0.0, -Z, -X,    X, 0.0, -Z,
                    0.0, -Z, -X,    Z, -X, 0.0,     X, 0.0, -Z,
                    0.0, -Z, -X,    0.0, -Z, X,     Z, -X, 0.0,
                    0.0, -Z, -X,    -Z, -X, 0.0,    0.0, -Z, X,
                    -Z, -X, 0.0,    -X, 0.0, Z,     0.0, -Z, X,
                    -X, 0.0, Z,     X, 0.0, Z,      0.0, -Z, X,
                    0.0, -Z, X,     X, 0.0, Z,      Z, -X, 0.0,
                    -Z, X, 0.0,     -X, 0.0, Z,     -Z, -X, 0.0,
                    -Z, X, 0.0,     -Z, -X, 0.0,    -X, 0.0, -Z,
                    -Z, X, 0.0,     -X, 0.0, -Z,    0.0, Z, -X,
                    0.0, -Z, -X,    -X, 0.0, -Z,    -Z, -X, 0.0,
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

                icosahedronVertexPositionBuffer.itemSize = 3;
                icosahedronVertexPositionBuffer.numItems = 60;

                determineCenterPosition(vertices);
                icosahedronColorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, icosahedronColorBuffer);

                let colors = calculateNormVectors(vertices);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            }

            function calculateNormVectors(vertices) {
                let normVectors = [];
                for (let i = 0; i < vertices.length; i += 9) {
                    let ex1 = vertices[i + 3] - vertices[i];
                    let ey1 = vertices[i + 4] - vertices[i + 1];
                    let ez1 = vertices[i + 5] - vertices[i + 2];
                    let ex2 = vertices[i + 6] - vertices[i];
                    let ey2 = vertices[i + 7] - vertices[i + 1];
                    let ez2 = vertices[i + 8] - vertices[i + 2];

                    let nx = ey1 * ez2 - ez1 * ey2;
                    let ny = ez1 * ex2 - ex1 * ez2;
                    let nz = ex1 * ey2 - ey1 * ex2;

                    normVectors.push(nx, ny, nz);
                    normVectors.push(nx, ny, nz);
                    normVectors.push(nx, ny, nz);
                }
                return normVectors;
            }

            function determineCenterPosition(vertices) {
                let xCoordinates = [],  yCoordinates = [], zCoordinates = [];
                for (let i = 0; i < vertices.length; i += 3) {
                    xCoordinates.push(vertices[i]);
                    yCoordinates.push(vertices[i + 1]);
                    zCoordinates.push(vertices[i + 2]);
                }
                icosahedronCenterPosition.x = (Math.max(...xCoordinates) + Math.min(...xCoordinates)) / 2;
                icosahedronCenterPosition.y = (Math.max(...yCoordinates) + Math.min(...yCoordinates)) / 2;
                icosahedronCenterPosition.z = (Math.max(...zCoordinates) + Math.min(...zCoordinates)) / 2;
            }

            var xShift = 0, yShift = 0, zShift = 0, thetaX = 0, thetaY = 0;
            function drawScene() {
                glMatrix.mat4.perspective(pMatrix, glMatrix.glMatrix.toRadian(10), gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
                glMatrix.mat4.identity(mvMatrix);
                glMatrix.mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -15.0]);

                thetaX = (customThetaX-thetaX) / 180 * Math.PI;
                glMatrix.mat4.multiply(mvMatrix, mvMatrix,
                    [Math.cos(thetaX), 0, Math.sin(thetaX), 0,
                     0, 1, 0, 0,
                    -Math.sin(thetaX), 0, Math.cos(thetaX), 0,
                     0, 0, 0, 1]);

                thetaY = (customThetaY-thetaY) / 180 * Math.PI;
                glMatrix.mat4.multiply(mvMatrix, mvMatrix,
                    [1, 0, 0, 0,
                     0, Math.cos(thetaY), Math.sin(thetaY), 0,
                     0, -Math.sin(thetaY), Math.cos(thetaY), 0,
                     0, 0, 0, 1]);

                glMatrix.mat4.multiply(mvMatrix, mvMatrix,
                    [1, 0, 0, 0,
                     0, 1, 0, 0,
                     0, 0, 1, 0,
                     xShift, yShift, zShift, 1]);
            
                gl.bindBuffer(gl.ARRAY_BUFFER, icosahedronVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, icosahedronVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, icosahedronColorBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, icosahedronVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
                setUniforms();
                gl.drawArrays(gl.TRIANGLES, 0, icosahedronVertexPositionBuffer.numItems);
            }

            function webGLStart() {
                var canvas = document.getElementById("canvas");
                initGL(canvas);
                initShaders();
                initBuffers();

                gl.clearColor(0.0, 0.0, 1.0, 1.0);
                gl.enable(gl.DEPTH_TEST);

                drawScene();
            }

            var customThetaX = 0, customThetaY = 0, lastMousePos = { x: 0, y: 0 }, mousedown = false;
            document.addEventListener("mousedown", function (event) {
                mousedown = true;
                lastMousePos.x = event.clientX;
                lastMousePos.y = event.clientY;
            });
            
            document.addEventListener("mousemove", function (event) {
                let currentMousePos = { x: event.clientX, y: event.clientY };
                xShift = (-1) * icosahedronCenterPosition.x;
                yShift = (-1) * icosahedronCenterPosition.y;
                zShift = (-1) * icosahedronCenterPosition.z;
                if (mousedown) {
                    customThetaX += (currentMousePos.x - lastMousePos.x) * (-0.1);
                    customThetaY += (currentMousePos.y - lastMousePos.y) * (-0.1);

                    lastMousePos = currentMousePos;
                    requestAnimationFrame(drawScene);
                }
            });

            document.addEventListener("mouseup", function (event) {
                mousedown = false;
            });
        </script>
    </head>
    <body onload="webGLStart();">
        <canvas id="canvas" width="1080" height="1080"></canvas>
    </body>
</html>