<!DOCTYPE>
<html xml:lang>
    <head>
        <title>Phong</title>
        <style>
            body {
                display: flex;
                justify-content: center;
            }
        </style>

        <script type="text/javascript" src="js/gl-matrix-min.js"></script>

        <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aVertexColor;

        varying vec4 colorVector;
        varying vec4 specularityVector;

        uniform mat4 MVMatrix; 
        uniform mat4 PMatrix;
        uniform mat4 NormalMatrix;

        vec3 LightDirection = vec3(0.5, 0.5, 1.0);
        vec3 ObjectColor = vec3(1.0, 0.1, 0.1);
        vec3 LightColor = vec3(1.0, 1.0, 1.0);

        void main(void) {
            vec3 normal = -normalize((NormalMatrix * vec4(aVertexColor, 0.0)).xyz);
            colorVector = vec4(LightColor * ObjectColor * max(0.0, dot(normalize(LightDirection), normal)), 1.0);
            specularityVector = vec4(vec3(0.6, 0.6, 0.6) * pow(max(0.0, dot(-reflect(LightDirection, normal), vec3(0.0, 0.0, 1.0))), 1.0), 1.0);
            gl_Position =  PMatrix * MVMatrix * (vec4(aVertexPosition, 1)) + vec4(0,1,0,0);
        }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec4 colorVector;
        varying vec4 specularityVector;

        void main(void) {
            gl_FragColor = (1.0 * colorVector) + (1.0 * specularityVector);    
        }
        </script>

        <script type="text/javascript">

            var gl;
            function initGL(canvas) {
                gl = canvas.getContext("experimental-webgl");
                gl.viewportWidth = canvas.width;
                gl.viewportHeight = canvas.height;
            }

            function getShader(gl, id) {
                var shaderScript = document.getElementById(id);
                if (!shaderScript) {
                    return null;
                }

                var str = "";
                var k = shaderScript.firstChild;
                while (k) {
                    if (k.nodeType == 3)
                        str += k.textContent;
                    k = k.nextSibling;
                }

                var shader;
                if (shaderScript.type == "x-shader/x-fragment")
                    shader = gl.createShader(gl.FRAGMENT_SHADER);
                else if (shaderScript.type == "x-shader/x-vertex")
                    shader = gl.createShader(gl.VERTEX_SHADER);
                else
                    return null;

                gl.shaderSource(shader, str);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    alert(gl.getShaderInfoLog(shader));
                    return null;
                }

                return shader;
            }

            var shaderProgram;
            function initShaders() {
                var fragmentShader = getShader(gl, "shader-fs");
                var vertexShader = getShader(gl, "shader-vs");

                shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);
                gl.useProgram(shaderProgram);

                shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
                gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

                shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
                gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

                shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "PMatrix");
                shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "MVMatrix");
                shaderProgram.normalMatrixUnifrom = gl.getUniformLocation(shaderProgram, "NormalMatrix");
            }

            var mvMatrix = glMatrix.mat4.create();
            var pMatrix = glMatrix.mat4.create();
            function setUniforms() {
                var normalMatrix = glMatrix.mat4.clone(mvMatrix);
                glMatrix.mat4.invert(normalMatrix, normalMatrix);
                glMatrix.mat4.transpose(normalMatrix, normalMatrix);
                
                gl.uniformMatrix4fv(shaderProgram.normalMatrixUnifrom, false, normalMatrix);
                gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
                gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
            }

            var icosahedronVertexPositionBuffer;
            var icosahedronColorBuffer;
            var icosahedronCenterPosition = { x: 0, y: 0, z: 0 };
            function initBuffers() {
                icosahedronVertexPositionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, icosahedronVertexPositionBuffer);
                const X = 0.525731112119133606
                const Z = 0.850650808352039932
            
                var vertices = [
                    -X, 0.0, Z,     0.0, Z, X,      X, 0.0, Z,
                    -X, 0.0, Z,     -Z, X, 0.0,     0.0, Z, X,
                    -Z, X, 0.0,     0.0, Z, -X,     0.0, Z, X,
                    0.0, Z, X,      0.0, Z, -X,     Z, X, 0.0,
                    0.0, Z, X,      Z, X, 0.0,      X, 0.0, Z,
                    Z, X, 0.0,      Z, -X, 0.0,     X, 0.0, Z,
                    Z, X, 0.0,      X, 0.0, -Z,     Z, -X, 0.0,
                    0.0, Z, -X,     X, 0.0, -Z,     Z, X, 0.0,
                    0.0, Z, -X,     -X, 0.0, -Z,    X, 0.0, -Z,
                    -X, 0.0, -Z,    0.0, -Z, -X,    X, 0.0, -Z,
                    0.0, -Z, -X,    Z, -X, 0.0,     X, 0.0, -Z,
                    0.0, -Z, -X,    0.0, -Z, X,     Z, -X, 0.0,
                    0.0, -Z, -X,    -Z, -X, 0.0,    0.0, -Z, X,
                    -Z, -X, 0.0,    -X, 0.0, Z,     0.0, -Z, X,
                    -X, 0.0, Z,     X, 0.0, Z,      0.0, -Z, X,
                    0.0, -Z, X,     X, 0.0, Z,      Z, -X, 0.0,
                    -Z, X, 0.0,     -X, 0.0, Z,     -Z, -X, 0.0,
                    -Z, X, 0.0,     -Z, -X, 0.0,    -X, 0.0, -Z,
                    -Z, X, 0.0,     -X, 0.0, -Z,    0.0, Z, -X,
                    0.0, -Z, -X,    -X, 0.0, -Z,    -Z, -X, 0.0,
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

                icosahedronVertexPositionBuffer.itemSize = 3;
                icosahedronVertexPositionBuffer.numItems = 84;

                determineCenterPosition(vertices);

                icosahedronColorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, icosahedronColorBuffer);
                let colors = calculateNormVectors(vertices);
            
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            }

            function calculateNormVectors(vertices) {
                let normVectors = [];
                for (let i = 0; i < vertices.length; i += 9) {
                    let ex1 = vertices[i + 3] - vertices[i];
                    let ey1 = vertices[i + 4] - vertices[i + 1];
                    let ez1 = vertices[i + 5] - vertices[i + 2];
                    let ex2 = vertices[i + 6] - vertices[i];
                    let ey2 = vertices[i + 7] - vertices[i + 1];
                    let ez2 = vertices[i + 8] - vertices[i + 2];

                    let nx = ey1 * ez2 - ez1 * ey2;
                    let ny = ez1 * ex2 - ex1 * ez2;
                    let nz = ex1 * ey2 - ey1 * ex2;

                    normVectors.push(nx, ny, nz);
                    normVectors.push(nx, ny, nz);
                    normVectors.push(nx, ny, nz);
                }
                return normVectors;
            }

            function determineCenterPosition(vertices) {
                let xCoordinates = [];
                let yCoordinates = [];
                let zCoordinates = [];
                for (let i = 0; i < vertices.length; i += 3) {
                    xCoordinates.push(vertices[i]);
                    yCoordinates.push(vertices[i + 1]);
                    zCoordinates.push(vertices[i + 2]);
                }

                let xMax = Math.max(...xCoordinates);
                let yMax = Math.max(...yCoordinates);
                let zMax = Math.max(...zCoordinates);

                let xMin = Math.min(...xCoordinates);
                let yMin = Math.min(...yCoordinates);
                let zMin = Math.min(...zCoordinates);

                icosahedronCenterPosition.x = (xMax + xMin) / 2;
                icosahedronCenterPosition.y = (yMax + yMin) / 2;
                icosahedronCenterPosition.z = (zMax + zMin) / 2;
            }

            var xShift = 0;
            var yShift = 0;
            var zShift = 0;
            function drawScene() {
                glMatrix.mat4.perspective(pMatrix, glMatrix.glMatrix.toRadian(50), gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
                glMatrix.mat4.identity(mvMatrix);
                glMatrix.mat4.translate(mvMatrix, mvMatrix, [0.1, 0.0, -5.0]);

                let thetaX = customThetaX / 180 * Math.PI;
                glMatrix.mat4.multiply(mvMatrix, mvMatrix,
                    [Math.cos(thetaX), 0, Math.sin(thetaX), 0,
                     0, 1, 0, 0,
                    -Math.sin(thetaX), 0, Math.cos(thetaX), 0,
                     0, 0, 0, 1]);

                let thetaY = customThetaY / 180 * Math.PI;
                glMatrix.mat4.multiply(mvMatrix, mvMatrix,
                    [1, 0, 0, 0,
                     0, Math.cos(thetaY), Math.sin(thetaY), 0,
                     0, -Math.sin(thetaY), Math.cos(thetaY), 0,
                     0, 0, 0, 1]);

                glMatrix.mat4.multiply(mvMatrix, mvMatrix,
                    [1, 0, 0, 0,
                     0, 1, 0, 0,
                     0, 0, 1, 0,
                     xShift, yShift, zShift, 1]);
            
                gl.bindBuffer(gl.ARRAY_BUFFER, icosahedronVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, icosahedronVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, icosahedronColorBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, icosahedronVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                setUniforms();

                gl.uniform4f(shaderProgram.color, 1.0, 0.0, 1.0, 1.0);
                gl.drawArrays(gl.TRIANGLES, 0, icosahedronVertexPositionBuffer.numItems);
            }

            function webGLStart() {
                var canvas = document.getElementById("canvas");
                initGL(canvas);
                initShaders();
                initBuffers();

                gl.clearColor(0.0, 0.0, 1.0, 1.0);
                gl.enable(gl.DEPTH_TEST);

                drawScene();
            }

            var customThetaX = 0;
            var customThetaY = 0;
            let lastMousePos = { x: 0, y: 0 };

            let mousedown = false;
            document.addEventListener("mousedown", function (event) {
                mousedown = true;
                lastMousePos.x = event.clientX;
                lastMousePos.y = event.clientY;
            });
            
            document.addEventListener("mousemove", function (event) {
                let currentMousePos = {
                    x: event.clientX,
                    y: event.clientY
                };
                xShift = (-1) * icosahedronCenterPosition.x;
                yShift = (-1) * icosahedronCenterPosition.y;
                zShift = (-1) * icosahedronCenterPosition.z;
                if (mousedown) {
                    customThetaX += (currentMousePos.x - lastMousePos.x) * (-1);
                    customThetaY += (currentMousePos.y - lastMousePos.y) * (-1);

                    lastMousePos = currentMousePos;
                    requestAnimationFrame(drawScene);
                }
            });

            document.addEventListener("mouseup", function (event) {
                mousedown = false;
            });
        </script>
    </head>

    <body onload="webGLStart();">
        <canvas id="canvas" width="1080" height="1080"></canvas>
    </body>
</html>